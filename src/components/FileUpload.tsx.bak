import { useState, useRef, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { useToast } from '@/hooks/use-toast';
import { Upload, FileText, Image, FileX, Loader2, CheckCircle } from 'lucide-react';
import { Progress } from '@/components/ui/progress';
import * as pdfjsLib from 'pdfjs-dist';
import mammoth from 'mammoth';
import Tesseract from 'tesseract.js';

interface FileUploadProps {
  onTextExtracted: (text: string) => void;
}

// Set up PDF.js worker
try {
  pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;
} catch (error) {
  console.warn('PDF.js worker setup failed:', error);
}

const FileUpload = ({ onTextExtracted }: FileUploadProps) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [extractionProgress, setExtractionProgress] = useState(0);
  const [dragActive, setDragActive] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { toast } = useToast();

  // Global paste handler (paste image/file or plain text like Lens)
  useEffect(() => {
    const handlePaste = (e: ClipboardEvent) => {
      try {
        const cd = e.clipboardData as DataTransfer | null;
        if (!cd) return;

        // Prefer items API to catch images reliably
        const items = cd.items;
        if (items && items.length) {
          for (let i = 0; i < items.length; i++) {
            const it = items[i];
            if (it.kind === 'file') {
              const f = it.getAsFile();
              if (f) {
                validateAndSetFile(f);
                toast({ title: 'Pasted file detected', description: f.type || f.name || 'file' });
                e.preventDefault();
                return;
              }
            }
          }
        }

        // Fallback to files list
        const files = (cd as any).files as FileList | undefined;
        if (files && files.length > 0) {
          const f = files[0];
          validateAndSetFile(f);
          toast({ title: 'Pasted file detected', description: f.type || f.name || 'file' });
          e.preventDefault();
          return;
        }

        // Plain text
        const text: string = cd.getData('text') || '';
        if (text && text.trim().length > 0) {
          onTextExtracted(text.trim());
          toast({ title: 'Pasted text captured', description: `${text.trim().length} characters` });
          e.preventDefault();
        }
      } catch (err) {
        // ignore
      }
    };
    document.addEventListener('paste', handlePaste as any, true);
    return () => document.removeEventListener('paste', handlePaste as any, true);
  }, [onTextExtracted, toast]);

  const supportedFormats = {
    'text/plain': 'Text files (.txt)',
    'application/pdf': 'PDF files (.pdf)',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'Word documents (.docx)',
    'application/msword': 'Word documents (.doc)',
    'image/jpeg': 'JPEG images (.jpg, .jpeg)',
    'image/png': 'PNG images (.png)',
    'image/gif': 'GIF images (.gif)',
    'image/bmp': 'BMP images (.bmp)',
    'image/webp': 'WebP images (.webp)'
  };

  const extractTextFromFile = async (file: File): Promise<string> => {
    const fileType = file.type;
    
    // Handle text files
    if (fileType === 'text/plain') {
      return await file.text();
    }
    
    // Handle PDF files
    if (fileType === 'application/pdf') {
      return await extractTextFromPDF(file);
    }
    
    // Handle Word documents
    if (fileType.includes('wordprocessingml') || fileType === 'application/msword') {
      return await extractTextFromWord(file);
    }
    
    // Handle images (OCR)
    if (fileType.startsWith('image/')) {
      return await extractTextFromImage(file);
    }
    
    throw new Error('Unsupported file format');
  };

const extractTextFromPDF = async (file: File): Promise<string> => {
    try {
      setExtractionProgress(10);
      const arrayBuffer = await file.arrayBuffer();
      setExtractionProgress(25);

      if (!pdfjsLib || !pdfjsLib.getDocument) {
        throw new Error('PDF.js library not loaded properly');
      }

      const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer, verbosity: 0 });
      const pdf = await loadingTask.promise;
      const numPages = pdf.numPages;
      if (numPages === 0) throw new Error('PDF contains no pages');

      let extractedText = '';
      let pagesNeedingOCR: number[] = [];

      for (let pageNum = 1; pageNum <= numPages; pageNum++) {
        try {
          const page = await pdf.getPage(pageNum);
          const textContent = await page.getTextContent();
          const pageText = textContent.items
            .filter((item: any) => item.str && item.str.trim())
            .map((item: any) => item.str)
            .join(' ');

          if (pageText.trim().length > 10) {
            extractedText += pageText + '\n\n';
          } else {
            pagesNeedingOCR.push(pageNum);
          }

          setExtractionProgress(25 + (pageNum / numPages) * 35); // up to 60%
        } catch (e) {
          console.warn(`Text layer extraction failed on page ${pageNum}, switching to OCR`, e);
          pagesNeedingOCR.push(pageNum);
        }
      }

      // OCR pass for scanned pages
      if (pagesNeedingOCR.length) {
        for (let idx = 0; idx < pagesNeedingOCR.length; idx++) {
          const pageNum = pagesNeedingOCR[idx];
          try {
            const page = await pdf.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2 });
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            await page.render({ canvasContext: ctx as CanvasRenderingContext2D, viewport }).promise;

            const { data: { text } } = await Tesseract.recognize(canvas, 'eng+nep+sin', {
              logger: (m) => {
                if (m.status === 'recognizing text') {
                  const progressBase = 60 + (idx / pagesNeedingOCR.length) * 35; // 60-95%
                  setExtractionProgress(progressBase + (m.progress * (35 / pagesNeedingOCR.length)));
                }
              }
            });
            if (text && text.trim()) extractedText += text.trim() + '\n\n';
          } catch (ocrErr) {
            console.warn(`OCR failed on page ${pageNum}`, ocrErr);
          }
        }
      }

      setExtractionProgress(100);
      if (!extractedText.trim()) throw new Error('No readable text found in PDF');
      return extractedText.trim();
    } catch (error) {
      console.error('PDF extraction error:', error);
      if (error instanceof Error) {
        throw new Error(`PDF extraction failed: ${error.message}`);
      }
      throw new Error('Failed to extract text from PDF');
    }
  };

  const extractTextFromWord = async (file: File): Promise<string> => {
    try {
      setExtractionProgress(20);
      const arrayBuffer = await file.arrayBuffer();
      setExtractionProgress(50);
      
      const result = await mammoth.extractRawText({ arrayBuffer });
      setExtractionProgress(100);
      
      if (!result.value.trim()) {
        throw new Error('No text found in the Word document');
      }
      
      return result.value;
    } catch (error) {
      console.error('Word extraction error:', error);
      throw new Error('Failed to extract text from Word document');
    }
  };

  const extractTextFromImage = async (file: File): Promise<string> => {
    try {
      setExtractionProgress(10);
      
      const { data: { text } } = await Tesseract.recognize(
        file,
        'eng+hin+nep+sin', // Support multiple languages
        {
          logger: (m) => {
            if (m.status === 'recognizing text') {
              setExtractionProgress(20 + (m.progress * 70));
            }
          }
        }
      );
      
      setExtractionProgress(100);
      
      if (!text.trim()) {
        throw new Error('No text found in the image');
      }
      
      return text.trim();
    } catch (error) {
      console.error('OCR extraction error:', error);
      throw new Error('Failed to extract text from image');
    }
  };

const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;
    validateAndSetFile(file);
  };

  const validateAndSetFile = (file: File) => {
    // Validate file type
    if (!Object.keys(supportedFormats).includes(file.type)) {
      toast({
        title: 'Unsupported file format',
        description: 'Please upload a supported file format (PDF, Word, images, or text files)',
        variant: 'destructive'
      });
      return;
    }

    // Validate file size (max 20MB)
    if (file.size > 20 * 1024 * 1024) {
      toast({
        title: 'File too large',
        description: 'Please upload a file smaller than 20MB',
        variant: 'destructive'
      });
      return;
    }

    setUploadedFile(file);
    // Auto-start extraction like Lens
    setTimeout(() => processFile(), 50);
  };

  const processFile = async () => {
    if (!uploadedFile) return;

    setIsProcessing(true);
    setExtractionProgress(0);
    
    try {
      const extractedText = await extractTextFromFile(uploadedFile);
      onTextExtracted(extractedText);
      
      toast({
        title: 'Text extracted successfully!',
        description: `Extracted ${extractedText.length} characters from ${uploadedFile.name}`,
      });
      
      // Keep the file card visible with details and let user upload another
    } catch (error) {
      console.error('File processing error:', error);
      toast({
        title: 'Text extraction failed',
        description: error instanceof Error ? error.message : 'Unknown error occurred',
        variant: 'destructive'
      });
    } finally {
      setIsProcessing(false);
      setExtractionProgress(0);
    }
  };

  const removeFile = () => {
    setUploadedFile(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  const getFileIcon = (fileType: string) => {
    if (fileType.startsWith('image/')) return <Image className="h-4 w-4" />;
    if (fileType === 'application/pdf') return <FileText className="h-4 w-4" />;
    if (fileType.includes('word')) return <FileText className="h-4 w-4" />;
    return <FileText className="h-4 w-4" />;
  };

  return (
    <div className="space-y-4">
      {/* File Upload Area */}
      <div
        className={`relative border-2 border-dashed rounded-lg p-8 text-center transition-all duration-300 ${dragActive ? 'border-blue-500 bg-blue-900/10' : 'border-purple-400/60 hover:border-purple-400/80 hover:bg-purple-900/10'} bg-black/20`}
        onDragOver={(e) => { e.preventDefault(); setDragActive(true); }}
        onDragLeave={() => setDragActive(false)}
        onDrop={(e) => {
          e.preventDefault();
          setDragActive(false);
          const file = e.dataTransfer.files?.[0];
          if (file) {
            validateAndSetFile(file);
          } else {
            const dropText = e.dataTransfer.getData('text/plain');
            if (dropText && dropText.trim().length) {
              onTextExtracted(dropText.trim());
              toast({ title: 'Text dropped', description: `${dropText.trim().length} characters` });
            }
          }
        }}
      >
        {/* Also capture paste directly on the drop area */}
        <div
          onPaste={(e: any) => {
            // Let the global handler handle; prevent default if plain text is present to avoid double insert into focused input
            const txt = e.clipboardData?.getData('text');
            if (txt && txt.trim()) e.preventDefault();
          }}
        >
        {!uploadedFile && (
          <input
            ref={fileInputRef}
            type="file"
            onChange={handleFileSelect}
            accept=".txt,.pdf,.doc,.docx,.jpg,.jpeg,.png,.gif,.bmp,.webp"
            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10"
            id="file-upload"
          />
        )}
        
        <div className="relative z-0">
          {!uploadedFile ? (
            <div className="flex flex-col items-center pointer-events-none">
              <Upload className="h-12 w-12 text-purple-400 mx-auto mb-4" />
              <p className="text-slate-800 font-semibold mb-2 drop-shadow-lg bg-white/90 px-4 py-2 rounded-lg">
                Upload file to extract text
              </p>
              <p className="text-slate-700 text-sm mb-4 drop-shadow-md bg-white/80 px-3 py-1 rounded font-medium">
                Supports PDF, Word docs, images, and text files (Max 10MB)
              </p>
              <div className="bg-purple-600 text-white px-6 py-2 rounded-lg border border-purple-400/50 font-medium drop-shadow-lg">
                üìÅ Choose File
              </div>
            </div>
          ) : (
            <div className="space-y-4">
              <div className="flex items-center justify-center space-x-3 bg-white/90 rounded-lg p-4 border border-purple-200 shadow-lg">
                <div className="text-purple-600">{getFileIcon(uploadedFile.type)}</div>
                <div className="text-left">
                  <p className="text-slate-800 font-semibold">{uploadedFile.name}</p>
                  <p className="text-slate-600 text-sm font-medium">
                    {(uploadedFile.size / 1024 / 1024).toFixed(2)} MB
                  </p>
                </div>
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={removeFile}
                  className="text-red-400 hover:text-red-300 hover:bg-red-900/20"
                >
                  <FileX className="h-4 w-4" />
                </Button>
              </div>
              
              {isProcessing && extractionProgress > 0 && (
                <div className="bg-white/80 p-3 rounded-lg border border-blue-200">
                  <div className="flex justify-between text-sm mb-2">
                    <span className="text-blue-700 font-medium">Extracting text...</span>
                    <span className="text-blue-600 font-bold">{Math.round(extractionProgress)}%</span>
                  </div>
                  <Progress value={extractionProgress} className="h-2" />
                </div>
              )}
              
              <div className="flex space-x-3">
                <Button
                  onClick={processFile}
                  disabled={isProcessing}
                  className="flex-1 bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700"
                >
                  {isProcessing ? (
                    <>
                      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      Extracting Text...
                    </>
                  ) : (
                    <>
                      <CheckCircle className="mr-2 h-4 w-4" />
                      Extract Again
                    </>
                  )}
                </Button>
                <Button
                  variant="outline"
                  onClick={() => {
                    setUploadedFile(null);
                    if (fileInputRef.current) fileInputRef.current.value = '';
                  }}
                  className="min-w-32"
                >
                  Upload Another
                </Button>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Keyboard hint */}
      <div className="text-center">
        <p className="text-slate-600 text-xs font-medium bg-white/80 px-4 py-2 rounded-full inline-block mr-2">
          Tip: Press Ctrl+V to paste screenshots or copied text directly
        </p>
      </div>

      {/* Supported Formats */}
      <div className="text-center">
        <p className="text-slate-600 text-xs font-medium bg-white/80 px-4 py-2 rounded-full inline-block">
          Drag & drop files or paste (Ctrl+V) images/text. Supported: PDF, Word (.doc/.docx), Images (JPG, PNG, GIF, BMP, WebP), Text files
        </p>
      </div>
    </div>
  );
};

export default FileUpload;